#!/usr/bin/python

###############################################################################
#                                                                             #
#                         Pi-Star Service Watchdog                            #
#                                                                             #
#    Version 1.8, Code, Design and Development by Andy Taylor (MW0MWZ).       #
#                                                                             #
#   The service watchdog will monitor the D-Star Services, restarting them    #
#   after any kind of failures - something that used to happen occasionally   #
#             when using the origional G4KLX D-Star software.                 #
#                                                                             #
###############################################################################

import subprocess
import time
import os
import linecache
import datetime
import ConfigParser

time.sleep(90) #Assumiing the Pi has just started up, let the services settle...

while True: #Main loop
	# Get the current status
	dstarrepeater = "/etc/dstar-radio.dstarrepeater"
	mmdvmhost = "/etc/dstar-radio.mmdvmhost"

	# Check the D-Star Specific Services
	if os.path.isfile(dstarrepeater):
		checkprocdstar = subprocess.Popen('pgrep' + ' dstarrepeaterd', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if not checkprocdstar.stdout.readlines():
			checkprocdstar.wait()
			os.system('/bin/systemctl stop dstarrepeater.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start dstarrepeater.service')
			time.sleep(10) #Give the service time to start before we move on
		else:
			checkprocdstar.wait()

		# At this point it's a safe bet that the service is running, now look for signs of DVAP failure.
		utcnow = datetime.datetime.utcnow()
		datenow = utcnow.strftime('%Y-%m-%d')
		dateminus300sec = datetime.datetime.utcnow() - datetime.timedelta(minutes=5)
		logstampnow = utcnow.strftime('%Y-%m-%d %H:%M:%S')
		logstampnowminus300sec = dateminus300sec.strftime('%Y-%m-%d %H:%M:%S')
		currentLog = '/var/log/pi-star/DStarRepeater-' + datenow + '.log'

		# Open the DStarRepeater Log
		logfile = open(currentLog, 'r')
		loglist = logfile.readlines()
		logfile.close()

		# Parse the log lines
		for line in loglist:
			# We only care about logs in the last 60 secs
			if line[3:22] >= logstampnowminus300sec and line[3:22] <= logstampnow:
				# Now we look for DVAP failure lines
				if (str('Bad DVAP header') in line) or (str('Cannot open the D-Star modem') in line):
					os.system('/bin/systemctl stop dstarrepeater.service')
		                        time.sleep(30) # Give the DVAP time to recover
                		        os.system('/bin/systemctl start dstarrepeater.service')
                        		time.sleep(270) #Give the service time to start before we move on


	# Check the MMDVMHost Specific Services
	if os.path.isfile(mmdvmhost):
		checkprocmmdvm = subprocess.Popen('pgrep' + ' MMDVMHost', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if not checkprocmmdvm.stdout.readlines():
			checkprocmmdvm.wait()
			os.system('/bin/systemctl stop mmdvmhost.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start mmdvmhost.service')
			time.sleep(10) #Give the service time to start before we move on
		else:
			checkprocmmdvm.wait()
		
		checkprocdmrgateway = subprocess.Popen('pgrep' + ' DMRGateway', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if not checkprocdmrgateway.stdout.readlines():
			checkprocdmrgateway.wait()
			os.system('/bin/systemctl stop dmrgateway.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start dmrgateway.service')
			time.sleep(10) #Give the service time to start before we move on
		else:
			checkprocdmrgateway.wait()

		checkprocysfgateway = subprocess.Popen('pgrep' + ' YSFGateway', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if not checkprocysfgateway.stdout.readlines():
			checkprocysfgateway.wait()
			os.system('/bin/systemctl stop ysfgateway.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start ysfgateway.service')
			time.sleep(10) #Give the service time to start before we move on
		else:
			checkprocysfgateway.wait()

		checkprocp25gateway = subprocess.Popen('pgrep' + ' P25Gateway', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if not checkprocp25gateway.stdout.readlines():
			checkprocp25gateway.wait()
			os.system('/bin/systemctl stop p25gateway.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start p25gateway.service')
			time.sleep(10) #Give the service time to start before we move on
		else:
			checkprocp25gateway.wait()

		checkprocysfparrot = subprocess.Popen('pgrep' + ' YSFParrot', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if not checkprocysfparrot.stdout.readlines():
			checkprocysfparrot.wait()
			os.system('/bin/systemctl stop ysfparrot.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start ysfparrot.service')
			time.sleep(10) #Give the service time to start before we move on
		else:
			checkprocysfparrot.wait()

		checkprocp25parrot = subprocess.Popen('pgrep' + ' P25Parrot', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if not checkprocp25parrot.stdout.readlines():
			checkprocp25parrot.wait()
			os.system('/bin/systemctl stop p25parrot.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start p25parrot.service')
			time.sleep(10) #Give the service time to start before we move on
		else:
			checkprocp25parrot.wait()
		
		checkprocysf2dmr = subprocess.Popen('pgrep' + ' YSF2DMR', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if not checkprocysf2dmr.stdout.readlines():
			os.system('/bin/systemctl stop ysf2dmr.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start ysf2dmr.service')
			time.sleep(10) #Give the service time to start before we move on
		checkprocysf2dmr.wait()
		
	# Check the services that can be used by all systems
	checkprocirc = subprocess.Popen('pgrep' + ' ircddbgatewayd', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	if not checkprocirc.stdout.readlines():
		checkprocirc.wait()
		os.system('/bin/systemctl stop ircddbgateway.service')
		time.sleep(2) #Give the service time to stop before we move on
		os.system('/bin/systemctl start ircddbgateway.service')
		time.sleep(10) #Give the service time to start before we move on
	else:
		checkprocirc.wait()

	checkproctime = subprocess.Popen('pgrep' + ' timeserverd', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	if not checkproctime.stdout.readlines():
		checkproctime.wait()
		os.system('/bin/systemctl stop timeserver.service')
		time.sleep(2) #Give the service time to stop before we move on
		os.system('/bin/systemctl start timeserver.service')
		time.sleep(10) #Give the service time to start before we move on
	else:
		checkproctime.wait()

	# If PiStar-Remote not enabled, dont try and keep it running
	pistarRemoteConfig = ConfigParser.RawConfigParser()
	pistarRemoteConfig.read('/etc/pistar-remote')

	isEnabled = pistarRemoteConfig.get('enable', 'enabled')
	if (isEnabled == 'true'):
		checkprocremote = subprocess.check_output(['/usr/local/sbin/pistar-remote.service', 'status'])
		if "not" in checkprocremote:
			os.system('/bin/systemctl stop pistar-remote.service')
			time.sleep(2) #Give the service time to stop before we move on
			os.system('/bin/systemctl start pistar-remote.service')
			time.sleep(10) #Give the service time to start before we move on

#	checkprockeeper = subprocess.Popen('pgrep' + ' pistar-keeper', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
#	if not checkprockeeper.stdout.readlines():
#		checkprockeeper.wait()
#		os.system('service pistar-keeper start')
#		time.sleep(10) #Give the service time to start before we move on
#	else:
#		checkprockeeper.wait()

	time.sleep(300) #Time to wait between service checks
